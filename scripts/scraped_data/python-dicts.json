{
  "source": "https://realpython.com/python-dicts/",
  "content": "Table of Contents\nGetting Started With Python Dictionaries\nCreating Dictionaries in Python\nDictionary Literals\nThe dict() Constructor\nUsing the .fromkeys() Class Method\nAccessing Dictionary Values\nPopulating Dictionaries Incrementally\nAssigning Keys Manually\nAdding Keys in a for Loop\nBuilding Dictionaries With Comprehensions\nExploring the dict Class Methods\nRetrieving Data From Dictionaries\nAdding Key-Value Pairs and Updating Dictionaries\nRemoving Data From Dictionaries\nUsing Operators With Dictionaries\nMembership: in and not in\nEquality and Inequality: == and !=\nUnion and Augmented Union: | and |=\nUse Built-in Functions With Dictionaries\nChecking for Truthy Data in Dictionaries: all() and any()\nDetermining the Number of Dictionary Items: len()\nFinding Minimum and Maximum Values: min() and max()\nSorting Dictionaries by Keys, Values, and Items: sorted()\nSumming Dictionary Values: sum()\nIterating Over Dictionaries\nTraversing Dictionaries by Keys\nIterating Over Dictionary Values\nLooping Through Dictionary Items\nExploring Existing Dictionary-Like Classes\nCreating Custom Dictionary-Like Classes\nConclusion\nFrequently Asked Questions\nRemove ads\nWatch Now\nThis tutorial has a related video course created by the Real Python team. Watch it together with the written tutorial to deepen your understanding:\nUsing Dictionaries in Python\nPython dictionaries are a powerful built-in data type that allows you to store key-value pairs for efficient data retrieval and manipulation. Learning about them is essential for developers who want to process data efficiently. In this tutorial, you’ll explore how to create dictionaries using literals and the\ndict()\nconstructor, as well as how to use Python’s operators and built-in functions to manipulate them.\nBy learning about Python dictionaries, you’ll be able to access values through key lookups and modify dictionary content using various methods. This knowledge will help you in data processing, configuration management, and dealing with JSON and CSV data.\nBy the end of this tutorial, you’ll understand that:\nA dictionary in Python is a\nmutable collection of key-value pairs\nthat allows for efficient data retrieval using unique keys.\nBoth\ndict()\nand\n{}\ncan create dictionaries in Python. Use\n{}\nfor\nconcise syntax\nand\ndict()\nfor\ndynamic creation\nfrom iterable objects.\ndict()\nis a\nclass\nused to create dictionaries. However, it’s\ncommonly called a built-in function\nin Python.\n.__dict__\nis a\nspecial attribute\nin Python that holds an object’s\nwritable attributes\nin a dictionary.\nPython\ndict\nis implemented as a\nhashmap\n, which allows for\nfast key lookups\n.\nTo get the most out of this tutorial, you should be familiar with basic Python syntax and concepts such as\nvariables\n,\nloops\n, and\nbuilt-in functions\n. Some experience with\nbasic Python data types\nwill also be helpful.\nGet Your Code:\nClick here to download the free sample code\nthat you’ll use to learn about dictionaries in Python.\nTake the Quiz:\nTest your knowledge with our interactive “Dictionaries in Python” quiz. You’ll receive a score upon completion to help you track your learning progress:\nInteractive Quiz\nDictionaries in Python\nIn this quiz, you'll test your understanding of Python's dict data type. By working through this quiz, you'll revisit how to create and manipulate dictionaries, how to use Python's operators and built-in functions with them, and how they're implemented for efficient data retrieval.\nGetting Started With Python Dictionaries\nDictionaries\nare one of Python’s most important and useful built-in data types. They provide a mutable collection of key-value pairs that lets you efficiently access and mutate values through their corresponding keys:\nPython\n>>>\nconfig\n=\n{\n...\n\"color\"\n:\n\"green\"\n,\n...\n\"width\"\n:\n42\n,\n...\n\"height\"\n:\n100\n,\n...\n\"font\"\n:\n\"Courier\"\n,\n...\n}\n>>>\n# Access a value through its key\n>>>\nconfig\n[\n\"color\"\n]\n'green'\n>>>\n# Update a value\n>>>\nconfig\n[\n\"font\"\n]\n=\n\"Helvetica\"\n>>>\nconfig\n{\n'color': 'green',\n'width': 42,\n'height': 100,\n'font': 'Helvetica'\n}\nA Python dictionary consists of a collection of key-value pairs, where each key corresponds to its associated value. In this example,\n\"color\"\nis a key, and\n\"green\"\nis the associated value.\nDictionaries are a fundamental part of Python. You’ll find them behind core concepts like scopes and namespaces as seen with the\nbuilt-in functions\nglobals()\nand\nlocals()\n:\nPython\n>>>\nglobals\n()\n{\n'__name__': '__main__',\n'__doc__': None,\n'__package__': None,\n...\n}\nThe\nglobals()\nfunction returns a dictionary containing key-value pairs that map names to objects that live in your current global scope.\nPython also uses dictionaries to support the internal implementation of\nclasses\n. Consider the following demo class:\nPython\n>>>\nclass\nNumber\n:\n...\ndef\n__init__\n(\nself\n,\nvalue\n):\n...\nself\n.\nvalue\n=\nvalue\n...\n>>>\nNumber\n(\n42\n)\n.\n__dict__\n{'value': 42}\nThe\n.__dict__\nspecial attribute is a dictionary that maps attribute names to their corresponding values in Python classes and objects. This implementation makes attribute and method lookup fast and efficient in\nobject-oriented\ncode.\nYou can use dictionaries to approach many programming tasks in your Python code. They come in handy when processing\nCSV\nand\nJSON\nfiles, working with databases, loading configuration files, and more.\nPython’s dictionaries have the following characteristics:\nMutable\n: The dictionary values can be updated\nin place\n.\nDynamic\n: Dictionaries can grow and shrink as needed.\nEfficient\n: They’re implemented as\nhash tables\n, which allows for fast key lookup.\nOrdered\n: Starting with\nPython 3.7\n, dictionaries keep their items in the same\norder\nthey were inserted.\nThe keys of a dictionary have a couple of restrictions. They need to be:\nHashable\n: This means that you can’t use unhashable objects like lists as dictionary keys.\nUnique\n: This means that your dictionaries won’t have duplicate keys.\nIn contrast, the values in a dictionary aren’t restricted. They can be of any Python type, including other dictionaries, which makes it possible to have nested dictionaries.\nIt’s important to note that dictionaries are collections of pairs. So, you can’t insert a key without its corresponding value or vice versa. Since they come as a pair, you always have to insert a key with its corresponding value.\nNote:\nIn some situations, you may want to add keys to a dictionary without deciding what the associated value should be. In those cases, you can use the\n.setdefault()\nmethod to create keys with a default or placeholder value.\nIn practice, you can use a dictionary when you need an efficient and mutable data structure that maps keys to values. In the following sections, you’ll learn how to create and use dictionaries in your Python code.\nRemove ads\nCreating Dictionaries in Python\nYou can create Python dictionaries in a couple of ways, depending on your needs. The most common way is to use dictionary\nliterals\n, which are a comma-separated series of key-value pairs in curly braces. The second way is to use the\ndict()\nconstructor\n, which lets you create dictionaries from\niterables\nof key-value pairs, other mappings, or a series of keyword arguments. It also lets you create empty dictionaries when you call it without arguments.\nIn the following sections, you’ll dive deeper into how to create Python dictionaries using literals and the\ndict()\nconstructor.\nDictionary Literals\nYou can define a dictionary by enclosing a comma-separated series of key-value pairs in curly braces (\n{}\n). To separate the keys from their values, you need to use a colon (\n:\n). Here’s the syntax for a dictionary literal:\nPython Syntax\n{\n<\nkey_1\n>\n:\n<\nvalue_1\n>\n,\n<\nkey_2\n>\n:\n<\nvalue_2\n>\n,\n...\n,\n<\nkey_N\n>\n:\n<\nvalue_N\n>\n,\n}\nThe keys and values are completely optional, which means that you can use an empty pair of curly braces to create an empty dictionary. Then, you have the keys, a colon, and the value associated with the current key. To separate the pairs, you use a comma.\nThe keys must be\nhashable\nobjects like numbers, strings, or tuples. Being hashable means they can be passed to a hash function. A\nhash function\ntakes data of arbitrary size and maps it to a fixed-size value called a\nhash value\n—or just\nhash\n—which is used for table lookup and comparison. In Python, the built-in immutable data types are hashable, and the mutable types are unhashable.\nNote:\nPython\nsets\nalso use curly braces to define their literals, but they enclose individual elements rather than key-value pairs. To create an empty set, you need to use\nset()\ninstead of an empty pair of curly braces because this syntax is reserved for empty dictionaries.\nThe following code defines a dictionary that maps cities or states to the names of their corresponding Major League Baseball (MLB) teams:\nPython\n>>>\nMLB_teams\n=\n{\n...\n\"Colorado\"\n:\n\"Rockies\"\n,\n...\n\"Chicago\"\n:\n\"White Sox\"\n,\n...\n\"Boston\"\n:\n\"Red Sox\"\n,\n...\n\"Minnesota\"\n:\n\"Twins\"\n,\n...\n\"Milwaukee\"\n:\n\"Brewers\"\n,\n...\n\"Seattle\"\n:\n\"Mariners\"\n,\n...\n}\nYou can only use hashable Python objects as dictionary keys. The following example shows a dictionary with integer, float, and Boolean objects used as keys:\nPython\n>>>\n{\n42\n:\n\"aaa\"\n,\n2.78\n:\n\"bbb\"\n,\nTrue\n:\n\"ccc\"\n}\n{42: 'aaa', 2.78: 'bbb', True: 'ccc'}\nYou can even use objects like data types and functions as keys:\nPython\n>>>\ntypes\n=\n{\nint\n:\n1\n,\nfloat\n:\n2\n,\nbool\n:\n3\n}\n>>>\ntypes\n{<class 'int'>: 1, <class 'float'>: 2, <class 'bool'>: 3}\n>>>\ntypes\n[\nfloat\n]\n2\n>>>\ntypes\n[\nbool\n]\n3\nHowever, you can’t use unhashable objects as keys. If you try to, then you’ll get an error:\nPython\n>>>\n{[\n1\n,\n2\n]:\n\"A list as a key? Hmm...\"\n}\nTraceback (most recent call last):\n...\nTypeError\n:\nunhashable type: 'list'\nPython lists are unhashable because any changes to their content would change their hash value, violating the requirement that hash values must remain constant for hashable types. In practice, you can’t use any\nmutable\ndata type as a key in a dictionary. This means that lists, sets, and dictionaries themselves aren’t allowed.\nIf you need to use\nsequences\nas dictionary keys, then you can use tuples because tuples are immutable:\nPython\n>>>\na_dict\n=\n{(\n1\n,\n1\n):\n\"a\"\n,\n(\n1\n,\n2\n):\n\"b\"\n,\n(\n2\n,\n1\n):\n\"c\"\n,\n(\n2\n,\n2\n):\n\"d\"\n}\n>>>\na_dict\n[(\n1\n,\n1\n)]\n'a'\n>>>\na_dict\n[(\n2\n,\n1\n)]\n'c'\nIt’s important to note that even though tuples are immutable, they can contain mutable objects. You can’t use a tuple that contains mutable objects as a dictionary key:\nPython\n>>>\n{(\n1\n,\n[\n1\n,\n1\n]):\n\"a\"\n}\nTraceback (most recent call last):\n...\nTypeError\n:\nunhashable type: 'list'\nIn this example, the tuple that you try to use as a dictionary key contains a list. As a result, the tuple isn’t hashable anymore, so you get an error.\nDuplicate keys aren’t allowed in Python’s\ndict\ndata type. Because of this restriction, when you assign a value to an existing key, you won’t add a second instance of the key. Instead, you’ll replace the previously associated value with a new one.\nFor example, say that a given city has a second MLB team. You may try to add the second team by assigning it to the same key:\nPython\n>>>\nMLB_teams\n[\n\"Chicago\"\n]\n=\n\"Cubs\"\n>>>\nMLB_teams\n{\n'Colorado': 'Rockies',\n'Chicago': 'Cubs',\n'Boston': 'Red Sox',\n'Minnesota': 'Twins',\n'Milwaukee': 'Brewers',\n'Seattle': 'Mariners',\n}\nIn this example, you try to add a new key-value pair for the second MLB team in Chicago. However, what happens is that you replace the old team name (\n\"White Sox\"\n) with the new one (\n\"Cubs\"\n).\nSimilarly, if you specify a key a second time during the creation of a dictionary, the second occurrence will override the first:\nPython\n>>>\nMLB_teams\n=\n{\n...\n\"Colorado\"\n:\n\"Rockies\"\n,\n...\n\"Chicago\"\n:\n\"White Sox\"\n,\n...\n\"Chicago\"\n:\n\"Cubs\"\n,\n...\n\"Boston\"\n:\n\"Red Sox\"\n,\n...\n\"Minnesota\"\n:\n\"Twins\"\n,\n...\n\"Milwaukee\"\n:\n\"Brewers\"\n,\n...\n\"Seattle\"\n:\n\"Mariners\"\n,\n...\n}\n>>>\nMLB_teams\n{\n'Colorado': 'Rockies',\n'Chicago': 'Cubs',  # \"White Sox\" is not present\n'Boston': 'Red Sox',\n'Minnesota': 'Twins',\n'Milwaukee': 'Brewers',\n'Seattle': 'Mariners'\n}\nIn this example, your dictionary ends up containing the\n\"Chicago\": \"Cubs\"\npair because you inserted it after\n\"Chicago\": \"White Sox\"\nwith the same key.\nUnlike dictionary keys, there are no restrictions for dictionary values. Literally none at all. A dictionary value can be any type of object, including mutable types like lists and dictionaries, as well as user-defined objects:\nPython\n>>>\nclass\nPoint\n:\n...\ndef\n__init__\n(\nself\n,\nx\n,\ny\n):\n...\nself\n.\nx\n=\nx\n...\nself\n.\ny\n=\ny\n...\n>>>\n{\n...\n\"colors\"\n:\n[\n\"red\"\n,\n\"green\"\n,\n\"blue\"\n],\n...\n\"plugins\"\n:\n{\n\"py_code\"\n,\n\"dev_sugar\"\n,\n\"fasting_py\"\n},\n...\n\"timeout\"\n:\n3\n,\n...\n\"position\"\n:\nPoint\n(\n42\n,\n21\n),\n...\n}\nIn this example, you create a dictionary with a list, a set, an integer, and a custom object as values. All these objects work because values have no restrictions.\nThere’s also no restriction against a particular value appearing in a dictionary multiple times:\nPython\n>>>\n{\n0\n:\n\"a\"\n,\n1\n:\n\"a\"\n,\n2\n:\n\"a\"\n,\n3\n:\n\"a\"\n}\n{0: 'a', 1: 'a', 2: 'a', 3: 'a'}\nIn this example, your dictionary contains multiple instances of the letter\na\nas a value. This is completely okay because values don’t have the restriction of needing to be unique.\nRemove ads\nThe\ndict()\nConstructor\nYou can also build dictionaries with the\ndict()\nconstructor. The arguments to\ndict()\ncan be a series of keyword arguments, another mapping, or an iterable of key-value pairs. Here are the constructor’s signatures:\nPython Syntax\ndict\n()\ndict\n(\n**\nkwargs\n)\ndict\n(\nmapping\n,\n**\nkwargs\n)\ndict\n(\niterable\n,\n**\nkwargs\n)\nIf you call the\ndict()\nconstructor without arguments, then you get an empty dictionary:\nPython\n>>>\ndict\n()\n{}\nIn most cases, you’ll use an empty pair of curly braces to create empty dictionaries. However, in some situations, using the constructor might be more explicit.\nIf the keys of your dictionary are strings representing valid Python\nidentifiers\n, then you can specify them as keyword arguments. Here’s how you’d create the\nMLB_teams\ndictionary with this approach:\nPython\n>>>\nMLB_teams\n=\ndict\n(\n...\nColorado\n=\n\"Rockies\"\n,\n...\nChicago\n=\n\"White Sox\"\n,\n...\nBoston\n=\n\"Red Sox\"\n,\n...\nMinnesota\n=\n\"Twins\"\n,\n...\nMilwaukee\n=\n\"Brewers\"\n,\n...\nSeattle\n=\n\"Mariners\"\n,\n...\n)\n>>>\nMLB_teams\n{\n'Colorado': 'Rockies',\n'Chicago': 'White Sox',\n'Boston': 'Red Sox',\n'Minnesota': 'Twins',\n'Milwaukee': 'Brewers',\n'Seattle': 'Mariners'\n}\nAgain, to build a dictionary using keyword arguments, the keys must be strings holding valid Python names. Otherwise, they won’t work as argument names. This is a syntactical restriction of Python.\nYou can also create a dictionary from an iterable of key-value pairs. Here’s how you can build the\nMLB_teams\ndictionary this way:\nPython\n>>>\nMLB_teams\n=\ndict\n(\n...\n[\n...\n(\n\"Colorado\"\n,\n\"Rockies\"\n),\n...\n(\n\"Chicago\"\n,\n\"White Sox\"\n),\n...\n(\n\"Boston\"\n,\n\"Red Sox\"\n),\n...\n(\n\"Minnesota\"\n,\n\"Twins\"\n),\n...\n(\n\"Milwaukee\"\n,\n\"Brewers\"\n),\n...\n(\n\"Seattle\"\n,\n\"Mariners\"\n),\n...\n]\n...\n)\n>>>\nMLB_teams\n{\n'Colorado': 'Rockies',\n'Chicago': 'White Sox',\n'Boston': 'Red Sox',\n'Minnesota': 'Twins',\n'Milwaukee': 'Brewers',\n'Seattle': 'Mariners'\n}\nIn this example, you build the dictionary using a list of two-item tuples. The first item acts as the key, and the second is the associated value.\nA cool way to create dictionaries from sequences of values is to combine them with the built-in\nzip()\nfunction and then call\ndict()\nas shown below:\nPython\n>>>\nplaces\n=\n[\n...\n\"Colorado\"\n,\n...\n\"Chicago\"\n,\n...\n\"Boston\"\n,\n...\n\"Minnesota\"\n,\n...\n\"Milwaukee\"\n,\n...\n\"Seattle\"\n,\n...\n]\n>>>\nteams\n=\n[\n...\n\"Rockies\"\n,\n...\n\"White Sox\"\n,\n...\n\"Red Sox\"\n,\n...\n\"Twins\"\n,\n...\n\"Brewers\"\n,\n...\n\"Mariners\"\n,\n...\n]\n>>>\ndict\n(\nzip\n(\nplaces\n,\nteams\n))\n{\n'Colorado': 'Rockies',\n'Chicago': 'White Sox',\n'Boston': 'Red Sox',\n'Minnesota': 'Twins',\n'Milwaukee': 'Brewers',\n'Seattle': 'Mariners'\n}\nThe\nzip()\nfunction takes one or more iterables as arguments and yields tuples that combine items from each iterable. Note that your original data must be stored in ordered sequences for this technique to work correctly because the order is essential. Otherwise, you can end up with a dictionary that maps keys to values incorrectly.\nUsing the\n.fromkeys()\nClass Method\nThe\ndict\ndata type has a class method called\n.fromkeys()\nthat lets you create new dictionaries from an iterable of keys and a default value. The method’s signature looks like the following:\nPython Syntax\n.\nfromkeys\n(\niterable\n,\nvalue\n=\nNone\n,\n/\n)\nThe\niterable\nargument provides the keys that you want to include in your dictionary. Even though the input iterable can have duplicate items, the final dictionary will have unique keys as usual.\nThe\nvalue\nargument allows you to define an appropriate default value for all the keys. This argument defaults to\nNone\n, which can serve as a good default value in several scenarios. Here’s an example of how to create a new dictionary with the\n.fromkeys()\nmethod:\nPython\n>>>\ninventory\n=\ndict\n.\nfromkeys\n([\n\"apple\"\n,\n\"orange\"\n,\n\"banana\"\n,\n\"mango\"\n],\n0\n)\n>>>\ninventory\n{'apple': 0, 'orange': 0, 'banana': 0, 'mango': 0}\nIn this example, you create a dictionary to store an inventory of fruits. Initially, you have the list of fruits in stock but don’t have the corresponding amounts. So, you use\n0\nas the default amount in the call to\n.fromkeys()\n.\nRemove ads\nAccessing Dictionary Values\nOnce you’ve created a dictionary, you can access its content by keys. To retrieve a value from a dictionary, you can specify its corresponding key in square brackets (\n[]\n) after the dictionary name:\nPython\n>>>\nMLB_teams\n[\n\"Minnesota\"\n]\n'Twins'\n>>>\nMLB_teams\n[\n\"Colorado\"\n]\n'Rockies'\nYou can subscript a dictionary using specific keys to get their associated values. Key lookup in dictionaries is quite an efficient operation because dictionaries are implemented as hash tables.\nIf you refer to a key that isn’t in the dictionary, then Python raises an exception:\nPython\n>>>\nMLB_teams\n[\n\"Indianapolis\"\n]\nTraceback (most recent call last):\n...\nKeyError\n:\n'Indianapolis'\nWhen you try to access a key that doesn’t exist in a dictionary, you get a\nKeyError\nexception.\nNow say that you have the following dictionary with a person’s data:\nPython\n>>>\nperson\n=\n{\n...\n\"first_name\"\n:\n\"John\"\n,\n...\n\"last_name\"\n:\n\"Doe\"\n,\n...\n\"age\"\n:\n35\n,\n...\n\"spouse\"\n:\n\"Jane\"\n,\n...\n\"children\"\n:\n[\n\"Ralph\"\n,\n\"Betty\"\n,\n\"Bob\"\n],\n...\n\"pets\"\n:\n{\n\"dog\"\n:\n\"Frieda\"\n,\n\"cat\"\n:\n\"Sox\"\n},\n...\n}\nThis dictionary contains a list and dictionary as part of its values. To access the nested list elements, you can use the corresponding key and then the desired index. To access a key-value pair in a nested dictionary, you can use the outer key and then the inner:\nPython\n>>>\nperson\n[\n\"children\"\n][\n0\n]\n'Ralph'\n>>>\nperson\n[\n\"children\"\n][\n2\n]\n'Bob'\n>>>\nperson\n[\n\"pets\"\n][\n\"dog\"\n]\n'Frieda'\n>>>\nperson\n[\n\"pets\"\n][\n\"cat\"\n]\n'Sox'\nUsing the key and the index, you can access items in nested lists. Similarly, using the outer and inner keys, you can access values in nested dictionaries. Then, the nesting level will define how many keys or indices you’ll have to use.\nPopulating Dictionaries Incrementally\nPython dictionaries are dynamically sized data structures. This means that you can add key-value pairs to your dictionaries dynamically, and Python will take care of increasing the dictionary size for you. This characteristic is helpful because it lets you dynamically populate dictionaries with data.\nWhen populating dictionaries, there are three common techniques that you can use. You can:\nAssign keys manually\nAdd keys in a\nfor\nloop\nBuild a dictionary with a comprehension\nIn the following sections, you’ll learn how to use these techniques to populate your dictionaries in Python.\nAssigning Keys Manually\nSometimes, you start by creating an empty dictionary with an empty pair of curly braces. Then, you start adding new key-value pairs one at a time. Consider the following example where you populate a dictionary with a person’s data:\nPython\n>>>\nperson\n=\n{}\n>>>\nperson\n[\n\"first_name\"\n]\n=\n\"John\"\n>>>\nperson\n[\n\"last_name\"\n]\n=\n\"Doe\"\n>>>\nperson\n[\n\"age\"\n]\n=\n35\n>>>\nperson\n[\n\"spouse\"\n]\n=\n\"Jane\"\n>>>\nperson\n[\n\"children\"\n]\n=\n[\n\"Ralph\"\n,\n\"Betty\"\n,\n\"Bob\"\n]\n>>>\nperson\n[\n\"pets\"\n]\n=\n{\n\"dog\"\n:\n\"Frieda\"\n,\n\"cat\"\n:\n\"Sox\"\n}\n>>>\nperson\n{\n'first_name': 'John',\n'last_name': 'Doe',\n'age': 35,\n'spouse': 'Jane',\n'children': ['Ralph', 'Betty', 'Bob'],\n'pets': {'dog': 'Frieda', 'cat': 'Sox'}\n}\nYou can populate your dictionaries manually with new key-value pairs by assigning values to new keys. Internally, Python will create the key-value pair for you. It’s important to remember that keys are unique. If you assign a new value to an existing key, then the old value will be lost.\nRemove ads\nAdding Keys in a\nfor\nLoop\nYou’ll also find situations where a\nfor\nloop is a good approach for populating an empty dictionary with new data. For example, say that you have a\nrange\nof numbers and want to create a dictionary that maps each number to its corresponding square value. To create and populate the dictionary, you can use the following code:\nPython\n>>>\nsquares\n=\n{}\n>>>\nfor\ninteger\nin\nrange\n(\n1\n,\n10\n):\n...\nsquares\n[\ninteger\n]\n=\ninteger\n**\n2\n...\n>>>\nsquares\n{1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81}\nIn this example, you first create an empty dictionary using a pair of curly braces. Then, you use a loop to iterate over a range of integer numbers. Inside the loop, you populate the dictionary using the numbers as keys and the square values as the corresponding values.\nBuilding Dictionaries With Comprehensions\nPython has dictionary comprehensions, which is another great tool for creating and populating dictionaries with concise syntax. Here’s how you can create your\nsquare\ndictionary with a comprehension:\nPython\n>>>\nsquares\n=\n{\ninteger\n:\ninteger\n**\n2\nfor\ninteger\nin\nrange\n(\n1\n,\n10\n)}\n>>>\nsquares\n{1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81}\nDictionary comprehensions are expressions that build and return a new dictionary. In this example, you use a comprehension to create a dictionary that maps numbers to their square values.\nNote:\nTo learn more about dictionary comprehensions, check out the\nPython Dictionary Comprehensions: How and When to Use Them\ntutorial.\nComprehensions provide a powerful way to create new dictionaries, transform and filter existing dictionaries, and more. They’re a great tool for you to have under your belt.\nExploring the\ndict\nClass Methods\nPython dictionaries have several methods that you can call to perform common actions like accessing keys, values, and items. You’ll also find methods for updating and removing values. In the following sections, you’ll learn about these methods and how to use them in your Python code.\nRetrieving Data From Dictionaries\nTo get started, you’ll learn about methods you can use to access the data stored in an existing dictionary. You’ll also learn about methods for getting a single key and retrieving all the values, keys, and pairs from a dictionary. These methods are useful in real-world Python programming.\nGetting Individual Keys:\n.get(key, default=None)\nThe\n.get()\nmethod provides a convenient way to retrieve the value associated with a key without checking whether the key exists beforehand. The key you want to search for is the first argument to\n.get()\n. The second argument, which is optional, is a default value that will be used if the target key doesn’t exist in the dictionary. Note that the default value of\ndefault\nis\nNone\n:\nPython\n>>>\ninventory\n=\n{\n\"apple\"\n:\n100\n,\n\"orange\"\n:\n80\n,\n\"banana\"\n:\n100\n}\n>>>\ninventory\n.\nget\n(\n\"apple\"\n)\n100\n>>>\nprint\n(\ninventory\n.\nget\n(\n\"mango\"\n))\nNone\nIf the target key exists in the dictionary, then you get the corresponding value. If the key isn’t found in the dictionary and the optional\ndefault\nargument is specified, then you get\nNone\nas a result.\nYou can also provide a convenient value to\ndefault\n:\nPython\n>>>\ninventory\n.\nget\n(\n\"mango\"\n,\n0\n)\n0\nIn this example, the\n\"mango\"\nkey isn’t in the\ninventory\ndictionary. Because of this, you get the custom default value (\n0\n) as a result.\nRetrieving All the Values:\n.values()\nThe\n.values()\nmethod returns a\ndictionary view\nobject, which provides a dynamic view of the values in a dictionary:\nPython\n>>>\ninventory\n=\n{\n\"apple\"\n:\n100\n,\n\"orange\"\n:\n80\n,\n\"banana\"\n:\n100\n}\n>>>\ninventory\n.\nvalues\n()\ndict_values([100, 80, 100])\nThe\ndict_values\nobject contains all the values in\ninventory\n. Note that any duplicate values will be returned as many times as they occur.\nAccessing All the Keys:\n.keys()\nThe\n.keys()\nmethod returns a dictionary view object with a dynamic view of the keys in the target dictionary:\nPython\n>>>\ninventory\n=\n{\n\"apple\"\n:\n100\n,\n\"orange\"\n:\n80\n,\n\"banana\"\n:\n100\n}\n>>>\ninventory\n.\nkeys\n()\ndict_keys(['apple', 'orange', 'banana'])\nAgain, the view object\ndict_keys\ncontains all the keys in the\ninventory\ndictionary. Since dictionary keys are unique, you won’t get any duplicate keys.\nGetting All the Items or Key-Value Pairs:\n.items()\nThe\n.items()\nmethod returns a dictionary view containing tuples of keys and values. The first item in each tuple is the key, while the second item is the associated value:\nPython\n>>>\ninventory\n=\n{\n\"apple\"\n:\n100\n,\n\"orange\"\n:\n80\n,\n\"banana\"\n:\n100\n}\n>>>\ninventory\n.\nitems\n()\ndict_items([('apple', 100), ('orange', 80), ('banana', 100)])\nThe\ndict_items\nview object contains the key-value pairs of your\ninventory\ndictionary as two-item tuples of the form\n(key, value)\n.\nRemove ads\nAdding Key-Value Pairs and Updating Dictionaries\nPython’s built-in\ndict\ndata type also has methods for adding and updating key-value pairs. For this purpose, you have the\n.setdefault()\nand\n.update()\nmethods. You’ll learn about them in the following sections.\nSetting One Key:\n.setdefault(key, default=None)\nThe\n.setdefault()\nmethod lets you set default values to keys. If\nkey\nis in the dictionary, then the method returns the associated value. If\nkey\nisn’t in the dictionary, it’s inserted with\ndefault\nas its associated value. Then, it returns\ndefault\n:\nPython\n>>>\ninventory\n=\n{\n\"apple\"\n:\n100\n,\n\"orange\"\n:\n80\n}\n>>>\ninventory\n.\nsetdefault\n(\n\"apple\"\n)\n100\n>>>\nprint\n(\ninventory\n.\nsetdefault\n(\n\"mango\"\n))\nNone\n>>>\ninventory\n{'apple': 100, 'orange': 80, 'mango': None}\n>>>\ninventory\n.\nsetdefault\n(\n\"banana\"\n,\n0\n)\n0\n>>>\ninventory\n{'apple': 100, 'orange': 80, 'mango': None, 'banana': 0}\nWhen you call\n.setdefault()\nwith an existing key, you get the associated value. If the key is missing, you get\nNone\n—which is the\ndefault\nvalue—and a new key-value pair is inserted. If the key is missing and you provide a custom\ndefault\nvalue, then you get the custom\ndefault\nand a new key-value pair.\nUpdating a Dictionary:\n.update([other])\nThe\n.update()\nmethod merges a dictionary with another dictionary or with an iterable of key-value pairs. If\nother\nis a dictionary, then\na_dict.update(other)\nmerges the entries from\nother\ninto\na_dict\n. For each key in\nother\n, you can have one of the following results:\nIf the key isn’t present in\na_dict\n, then the key-value pair from\nother\nis added to\na_dict\n.\nIf the key is present in\na_dict\n, then the corresponding value in\na_dict\nis updated to the value in\nother\n.\nHere’s an example showing two dictionaries merged together:\nPython\n>>>\nconfig\n=\n{\n...\n\"color\"\n:\n\"green\"\n,\n...\n\"width\"\n:\n42\n,\n...\n\"height\"\n:\n100\n,\n...\n\"font\"\n:\n\"Courier\"\n,\n...\n}\n>>>\nuser_config\n=\n{\n...\n\"path\"\n:\n\"/home\"\n,\n...\n\"color\"\n:\n\"red\"\n,\n...\n\"font\"\n:\n\"Arial\"\n,\n...\n\"position\"\n:\n(\n200\n,\n100\n),\n...\n}\n>>>\nconfig\n.\nupdate\n(\nuser_config\n)\n>>>\nconfig\n{\n'color': 'red',\n'width': 42,\n'height': 100,\n'font': 'Arial',\n'path': '/home',\n'position': (200, 100)\n}\nIn this example, you update the\nconfig\ndictionary with content from the\nuser_config\ndictionary. Note how the existing keys were updated while the missing ones were added to the end of\nconfig\n.\nThe\nother\nargument may also be a sequence of key-value pairs:\nPython\n>>>\nconfig\n.\nupdate\n([(\n\"width\"\n,\n200\n),\n(\n\"api_key\"\n,\n1234\n)])\n>>>\nconfig\n{\n'color': 'red',\n'width': 200,\n'height': 100,\n'font': 'Arial',\n'path': '/home',\n'position': (200, 100),\n'api_key': 1234\n}\nHere, you pass a list of tuples as an argument to\n.update()\n. The method updates the existing keys or adds new keys as needed.\nFinally, you can also call\n.update()\nwith keyword arguments:\nPython\n>>>\nconfig\n.\nupdate\n(\ncolor\n=\n\"yellow\"\n,\nscript\n=\n\"__main__.py\"\n)\n>>>\nconfig\n{\n'color': 'yellow',\n'width': 200,\n'height': 100,\n'font': 'Arial',\n'path': '/home',\n'position': (200, 100),\n'api_key': 1234,\n'script': '__main__.py'\n}\nIn this example, you call\n.update()\nwith keyword arguments, and the method updates the existing keys or adds new keys as needed.\nRemoving Data From Dictionaries\nRemoving key-value pairs is another common operation that you may need to perform on your dictionaries. To do this, the\ndict\nclass provides a few useful methods. In the following sections, you’ll learn about these methods and how they work.\nRemoving Keys:\n.pop(key[, default])\nThe\n.pop()\nmethod removes key-value pairs by keys. If the key exists, then the method returns its associated value. On the other hand, if the key doesn’t exist and\ndefault\nisn’t provided, then you get a\nKeyError\n. Otherwise, you get the\ndefault\nvalue:\nPython\n>>>\ninventory\n=\n{\n\"apple\"\n:\n100\n,\n\"orange\"\n:\n80\n,\n\"banana\"\n:\n100\n}\n>>>\ninventory\n.\npop\n(\n\"apple\"\n)\n100\n>>>\ninventory\n{'orange': 80, 'banana': 100}\n>>>\ninventory\n.\npop\n(\n\"mango\"\n)\nTraceback (most recent call last):\n...\nKeyError\n:\n'mango'\n>>>\ninventory\n.\npop\n(\n\"mango\"\n,\n0\n)\n0\nIf the target key isn’t present in the dictionary, and the optional\ndefault\nargument is specified, then that value is returned and no exception is raised.\nWhen you want to both delete an item and retain its value, you’ll commonly use\n.pop()\n. If you just want to remove the item, then you typically go with the\ndel\nstatement:\nPython\n>>>\ndel\ninventory\n[\n\"banana\"\n]\n>>>\ninventory\n{'orange': 80}\nIn this example, you remove the\n\"banana\"\nkey and its associated value without returning the value as\n.pop()\ndoes.\nDeleting Items:\n.popitem()\nThe\n.popitem()\nmethod removes a key-value pair from a dictionary. This method returns the removed pair as a tuple of the form\n(key, value)\n. The pairs are removed in\nLIFO\n(last-in, first-out) order:\nPython\n>>>\ninventory\n=\n{\n\"apple\"\n:\n100\n,\n\"orange\"\n:\n80\n,\n\"banana\"\n:\n100\n}\n>>>\ninventory\n.\npopitem\n()\n('banana', 100)\n>>>\ninventory\n{'apple': 100, 'orange': 80}\n>>>\ninventory\n.\npopitem\n()\n('orange', 80)\n>>>\ninventory\n{'apple': 100}\n>>>\ninventory\n.\npopitem\n()\n('apple', 100)\n>>>\ninventory\n{}\nCalling\n.popitem()\nremoves a key-value pair from the dictionary and returns it as a two-item tuple. The first item is the key, and the second is the value. Note that the items are removed from right to left, starting with the last item added.\nNote:\nIn Python versions prior to 3.6,\n.popitem()\nreturned an arbitrary key-value pair because\nPython dictionaries were unordered\nbefore this version.\nIf the dictionary is empty, then\n.popitem()\nraises a\nKeyError\nexception:\nPython\n>>>\ninventory\n.\npopitem\n()\nTraceback (most recent call last):\n...\nKeyError\n:\n'popitem(): dictionary is empty'\nWhen you call\n.popitem()\non an empty dictionary, you get a\nKeyError\nbecause there are no items to remove.\nClearing Dictionaries:\n.clear()\nThe\n.clear()\nmethod removes all the items from a dictionary:\nPython\n>>>\ninventory\n=\n{\n\"apple\"\n:\n100\n,\n\"orange\"\n:\n80\n,\n\"banana\"\n:\n100\n}\n>>>\ninventory\n{'apple': 100, 'orange': 80, 'banana': 100}\n>>>\ninventory\n.\nclear\n()\n>>>\ninventory\n{}\nCalling the\n.clear()\nmethod on an existing dictionary will remove all the current key-value pairs from the dictionary.\nRemove ads\nUsing Operators With Dictionaries\nThere are a few Python operators you can use with dictionaries. The most notable ones are the membership, equality, and union operators. In the following sections, you’ll learn how these operators work with dictionaries by coding and running some quick examples.\nMembership:\nin\nand\nnot in\nThe membership operators\nin\nand\nnot in\nallow you to determine whether a given key, value, or item is in a dictionary, depending on the target iterable you use.\nNote:\nTo learn more about membership tests, check out\nPython’s “in” and “not in” Operators: Check for Membership\n.\nFor example, to check whether:\nA key is in a dictionary, you can use the dictionary itself or the\n.keys()\nmethod to provide the target iterable\nA value is in a dictionary, you can use the\n.values()\nmethod to provide the target iterable\nAn item is in a dictionary, you can use the\n.items()\nmethod to provide the target iterable\nTo illustrate, say that you want to check whether a given city is in your\nMLB_teams\ndictionary. To do this, you can use the\nin\nand\nnot in\noperator with the dictionary itself or with the\n.keys()\nmethod:\nPython\n>>>\nMLB_teams\n=\n{\n...\n\"Colorado\"\n:\n\"Rockies\"\n,\n...\n\"Chicago\"\n:\n\"White Sox\"\n,\n...\n\"Boston\"\n:\n\"Red Sox\"\n,\n...\n\"Minnesota\"\n:\n\"Twins\"\n,\n...\n\"Milwaukee\"\n:\n\"Brewers\"\n,\n...\n\"Seattle\"\n:\n\"Mariners\"\n,\n...\n}\n>>>\n\"Milwaukee\"\nin\nMLB_teams\nTrue\n>>>\n\"Indianapolis\"\nin\nMLB_teams\nFalse\n>>>\n\"Indianapolis\"\nnot\nin\nMLB_teams\nTrue\n>>>\n\"Milwaukee\"\nin\nMLB_teams\n.\nkeys\n()\nTrue\n>>>\n\"Indianapolis\"\nin\nMLB_teams\n.\nkeys\n()\nFalse\n>>>\n\"Indianapolis\"\nnot\nin\nMLB_teams\n.\nkeys\n()\nTrue\nIn the first membership test, you check whether Milwaukee is included in the\nMLB_teams\ndictionary. Because this city is in the dictionary, you get\nTrue\nas a result. Then, you check whether Indianapolis is a member of the dictionary, which returns\nFalse\n.\nIn this first series of examples, you use the dictionary as the target iterable for the\nin\nand\nnot in\noperators. In the second series of examples, you use\n.keys()\n. As you can see, both techniques work the same. However, using\n.keys()\nin membership is redundant and slightly less efficient than using the dictionary directly.\nFor an execution time comparison, click to open the collapsible section below and run the script on your computer:\nCompare Membership Test on\ndict\nvs\ndict.keys()\nShow/Hide\nRun this script to test the speed of membership tests on\ndict\nvs\ndict.keys()\n:\nPython\nmembership.py\nimport\ntimeit\nMLB_teams\n=\n{\n\"Colorado\"\n:\n\"Rockies\"\n,\n\"Chicago\"\n:\n\"White Sox\"\n,\n\"Boston\"\n:\n\"Red Sox\"\n,\n\"Minnesota\"\n:\n\"Twins\"\n,\n\"Milwaukee\"\n:\n\"Brewers\"\n,\n\"Seattle\"\n:\n\"Mariners\"\n,\n}\n# Run timeit to compare the membership test\ntime_in_dict\n=\ntimeit\n.\ntimeit\n(\n'\"Milwaukee\" in MLB_teams'\n,\nglobals\n=\nglobals\n(),\nnumber\n=\n1_000_000\n)\ntime_in_keys\n=\ntimeit\n.\ntimeit\n(\n'\"Milwaukee\" in MLB_teams.keys()'\n,\nglobals\n=\nglobals\n(),\nnumber\n=\n1_000_000\n)\ntime_not_in_dict\n=\ntimeit\n.\ntimeit\n(\n'\"Indianapolis\" in MLB_teams'\n,\nglobals\n=\nglobals\n(),\nnumber\n=\n1_000_000\n)\ntime_not_in_keys\n=\ntimeit\n.\ntimeit\n(\n'\"Indianapolis\" in MLB_teams.keys()'\n,\nglobals\n=\nglobals\n(),\nnumber\n=\n1_000_000\n)\nprint\n(\nf\n\"\n{\ntime_in_dict\n= }\nseconds\"\n,\nf\n\"\n{\ntime_in_keys\n= }\nseconds\"\n,\nf\n\"\n{\ntime_not_in_dict\n= }\nseconds\"\n,\nf\n\"\n{\ntime_not_in_keys\n= }\nseconds\"\n,\nsep\n=\n\"\n\\n\n\"\n,\n)\nThe script uses\ntimeit\nto repeat the membership tests one million times each. When you run it, you’ll see output similar to the following:\nShell\n$\npython\nmembership.py\ntime_in_dict     = 0.018622874980792403 seconds\ntime_in_keys     = 0.047137481975369155 seconds\ntime_not_in_dict = 0.018104779010172933 seconds\ntime_not_in_keys = 0.046951496973633766 seconds\nYou can see that while the differences are noticeable, they aren’t particularly significant.\nYou can also use the\nin\nand\nnot in\noperators with the\n.values()\nmethod to determine whether a given value is in your dictionary:\nPython\n>>>\n\"Rockies\"\nin\nMLB_teams\n.\nvalues\n()\nTrue\n>>>\n\"Rockies\"\nnot\nin\nMLB_teams\n.\nvalues\n()\nFalse\nIn this example, you use the\n.values()\nmethod to provide the target iterable for the membership test. This is how to know if a given team is in your dictionary.\nFinally, in some situations, you may want to know whether a key-value pair is in the target dictionary. To figure this out, you can use the membership operators with the\n.items()\nmethod:\nPython\n>>>\n(\n\"Boston\"\n,\n\"Red Sox\"\n)\nin\nMLB_teams\n.\nitems\n()\nTrue\n>>>\n(\n\"Boston\"\n,\n\"Red Sox\"\n)\nnot\nin\nMLB_teams\n.\nitems\n()\nFalse\nNote that in this example, you use a tuple containing the key-value pair as the value to check. Then, you use the\n.items()\nmethod to provide the target iterable.\nEquality and Inequality:\n==\nand\n!=\nThe equality (\n==\n) and inequality (\n!=\n) operators also work with dictionaries. These operators disregard element order when you use them with dictionaries, which is different from what happens with lists, for example:\nPython\n>>>\n[\n1\n,\n2\n,\n3\n]\n==\n[\n3\n,\n2\n,\n1\n]\nFalse\n>>>\n{\n1\n:\n1\n,\n2\n:\n2\n,\n3\n:\n3\n}\n==\n{\n3\n:\n3\n,\n2\n:\n2\n,\n1\n:\n1\n}\nTrue\n>>>\n[\n1\n,\n2\n,\n3\n]\n!=\n[\n3\n,\n2\n,\n1\n]\nTrue\n>>>\n{\n1\n:\n1\n,\n2\n:\n2\n,\n3\n:\n3\n}\n!=\n{\n3\n:\n3\n,\n2\n:\n2\n,\n1\n:\n1\n}\nFalse\nWhen you compare a list using the equality operator, the result depends on both the content and the order. In contrast, when you compare two dictionaries that contain the same series of key-value pairs, the order of those pairs isn’t considered. The inequality operator when used with dictionaries doesn’t consider the order of pairs either.\nRemove ads\nUnion and Augmented Union:\n|\nand\n|=\nThe union operator (\n|\n) creates a new dictionary by merging the keys and values of two initial dictionaries. The values of the dictionary to the right of the operator take precedence when both dictionaries share keys:\nPython\n>>>\ndefault_config\n=\n{\n...\n\"color\"\n:\n\"green\"\n,\n...\n\"width\"\n:\n42\n,\n...\n\"height\"\n:\n100\n,\n...\n\"font\"\n:\n\"Courier\"\n,\n...\n}\n>>>\nuser_config\n=\n{\n...\n\"path\"\n:\n\"/home\"\n,\n...\n\"color\"\n:\n\"red\"\n,\n...\n\"font\"\n:\n\"Arial\"\n,\n...\n\"position\"\n:\n(\n200\n,\n100\n),\n...\n}\n>>>\nconfig\n=\ndefault_config\n|\nuser_config\n>>>\nconfig\n{\n'color': 'red',\n'width': 42,\n'height': 100,\n'font': 'Arial',\n'path': '/home',\n'position': (200, 100)\n}\nIn this example, you merge the\ndefault_config\nand\nuser_config\ndictionaries to build the final\nconfig\ndictionary using the union operator.\nNote that the\n\"color\"\nand\n\"font\"\nkeys are common to both initial dictionaries,\ndefault_config\nand\nuser_config\n. After the union, the values associated with these keys in\nuser_config\nprevail. The key-value pairs that didn’t exist in\ndefault_config\nare added to the end of the new dictionary.\nSimilarly, the augmented union operator (\n|=\n) updates an existing dictionary with key-value pairs from another dictionary,\nmapping\n, or\niterable\nof key-value pairs. Again, when the operands share keys, the values from the right-hand side operand take priority:\nPython\n>>>\nconfig\n=\n{\n...\n\"color\"\n:\n\"green\"\n,\n...\n\"width\"\n:\n42\n,\n...\n\"height\"\n:\n100\n,\n...\n\"font\"\n:\n\"Courier\"\n,\n...\n}\n>>>\nuser_config\n=\n{\n...\n\"path\"\n:\n\"/home\"\n,\n...\n\"color\"\n:\n\"red\"\n,\n...\n\"font\"\n:\n\"Arial\"\n,\n...\n\"position\"\n:\n(\n200\n,\n100\n),\n...\n}\n>>>\nconfig\n|=\nuser_config\n>>>\nconfig\n{\n'color': 'red',\n'width': 42,\n'height': 100,\n'font': 'Arial',\n'path': '/home',\n'position': (200, 100)\n}\nIn this new version of the\nconfig\ndictionary, you don’t create a new dictionary for the final configuration. Instead, you update the existing dictionary with the content of\nuser_config\nusing the augmented union operator. In a sense, the augmented union operator works like the\n.update()\nmethod, updating an existing dictionary with the content of another.\nUse Built-in Functions With Dictionaries\nIn Python, you’ll find several built-in functions that you can use for processing or working with dictionaries. Here’s a quick summary of some of these functions:\nFunction\nDescription\nall()\nReturns\nTrue\nif all the items in an iterable are truthy and\nFalse\notherwise.\nany()\nReturns\nTrue\nif at least one element in the iterable is truthy and\nFalse\notherwise.\nlen()\nReturns an integer representing the number of items in the input object.\nmax()\nReturns the largest value in an iterable or series of arguments.\nmin()\nReturns the smallest value in an iterable or series of arguments.\nsorted()\nReturns a new sorted list of the elements in the iterable.\nsum()\nReturns the sum of a start value and the values in the input iterable from left to right.\nAs you can see, all these functions have different goals. Also, you can use them with different dictionary components. In the following sections, you’ll learn about using these functions to process Python dictionaries.\nChecking for Truthy Data in Dictionaries:\nall()\nand\nany()\nTo start off, say that you have a dictionary that maps products to their amounts. You want to know whether all of the products are stocked. To figure this out, you can use the\nall()\nfunction with the dictionary values as a target:\nPython\n>>>\ninventory\n=\n{\n\"apple\"\n:\n100\n,\n\"orange\"\n:\n80\n,\n\"banana\"\n:\n100\n,\n\"mango\"\n:\n200\n}\n>>>\nall\n(\ninventory\n.\nvalues\n())\nTrue\n>>>\n# Update the stock\n>>>\ninventory\n[\n\"mango\"\n]\n=\n0\n>>>\nall\n(\ninventory\n.\nvalues\n())\nFalse\nIn the first call to\nall()\n, you get\nTrue\nbecause all product amounts differ from\n0\n. In the second example, you get\nFalse\nbecause you’re out of mangoes. You can use the\nany()\nfunction in a similar fashion.\nNote:\nTo learn more about\nall()\nand\nany()\n, check out the following tutorials:\nPython’s\nall()\n: Check Your Iterables for Truthiness\nHow to Use\nany()\nin Python\nYou can use these functions with keys as well. To do this, you can use either the dictionary directly or the\n.keys()\nmethod. Finally, using these functions with items doesn’t make sense because the\n.items()\nmethod returns non-empty tuples.\nDetermining the Number of Dictionary Items:\nlen()\nSometimes, you need to know the number of key-value pairs in an existing dictionary. The built-in\nlen()\nfunction returns exactly that number:\nPython\n>>>\nMLB_teams\n=\n{\n...\n\"Colorado\"\n:\n\"Rockies\"\n,\n...\n\"Chicago\"\n:\n\"White Sox\"\n,\n...\n\"Boston\"\n:\n\"Red Sox\"\n,\n...\n\"Minnesota\"\n:\n\"Twins\"\n,\n...\n\"Milwaukee\"\n:\n\"Brewers\"\n,\n...\n\"Seattle\"\n:\n\"Mariners\"\n,\n...\n}\n>>>\nlen\n(\nMLB_teams\n)\n6\nWhen you use a dictionary as an argument for\nlen()\n, the function returns the number of items in the dictionary. In this example, the input dictionary has six key-value pairs, so you get 6 as a result.\nRemove ads\nFinding Minimum and Maximum Values:\nmin()\nand\nmax()\nIf you ever need to find the minimum and maximum value stored in a dictionary, then you can use the built-in\nmin()\nand\nmax()\nfunctions:\nPython\n>>>\ncomputer_parts\n=\n{\n...\n\"CPU\"\n:\n299.99\n,\n...\n\"Motherboard\"\n:\n149.99\n,\n...\n\"RAM\"\n:\n89.99\n,\n...\n\"GPU\"\n:\n499.99\n,\n...\n\"SSD\"\n:\n129.99\n,\n...\n\"Power Supply\"\n:\n79.99\n,\n...\n\"Case\"\n:\n99.99\n,\n...\n\"Cooling System\"\n:\n59.99\n,\n...\n}\n>>>\nmin\n(\ncomputer_parts\n.\nvalues\n())\n59.99\n>>>\nmax\n(\ncomputer_parts\n.\nvalues\n())\n499.99\nIn this example, you use the\nmin()\nand\nmax()\nfunctions to find the lower and higher prices with the\n.values()\nmethod. You can also use the functions with dictionary keys and even with items. However, note that these functions are mostly used with numeric values.\nSorting Dictionaries by Keys, Values, and Items:\nsorted()\nSorting the items of a dictionary may be another common requirement. To do this, you can use the built-in\nsorted()\nfunction. To illustrate, say that you have a dictionary matching student names with their average grades and you want to sort the data by grades.\nHere’s how you can do this sorting:\nPython\n>>>\nstudents\n=\n{\n...\n\"Alice\"\n:\n89.5\n,\n...\n\"Bob\"\n:\n76.0\n,\n...\n\"Charlie\"\n:\n92.3\n,\n...\n\"Diana\"\n:\n84.7\n,\n...\n\"Ethan\"\n:\n88.9\n,\n...\n\"Fiona\"\n:\n95.6\n,\n...\n\"George\"\n:\n73.4\n,\n...\n\"Hannah\"\n:\n81.2\n,\n...\n}\n>>>\ndict\n(\nsorted\n(\nstudents\n.\nitems\n(),\nkey\n=\nlambda\nitem\n:\nitem\n[\n1\n]))\n{\n'George': 73.4,\n'Bob': 76.0,\n'Hannah': 81.2,\n'Diana': 84.7,\n'Ethan': 88.9,\n'Alice': 89.5,\n'Charlie': 92.3,\n'Fiona': 95.6\n}\n>>>\ndict\n(\nsorted\n(\nstudents\n.\nitems\n(),\nkey\n=\nlambda\nitem\n:\nitem\n[\n1\n],\nreverse\n=\nTrue\n))\n{\n'Fiona': 95.6,\n'Charlie': 92.3,\n'Alice': 89.5,\n'Ethan': 88.9,\n'Diana': 84.7,\n'Hannah': 81.2,\n'Bob': 76.0,\n'George': 73.4\n}\nThe\nsorted()\nfunction returns a list of sorted values, so you wrap its call with\ndict()\nto build a new sorted dictionary. In the first call, you sort the items by value in ascending order. To do this, you use a\nlambda\nfunction that takes a two-value tuple as an argument and returns the second item, which has an index of\n1\n.\nIn the second call to\nsorted()\n, you set the\nreverse\nargument to\nTrue\nso that the function returns a list of items stored in reverse order.\nNote:\nTo dive deeper into sorting dictionaries, check out the\nSorting a Python Dictionary: Values, Keys, and More\ntutorial.\nYou can also sort the dictionary by its keys:\nPython\n>>>\ndict\n(\nsorted\n(\nstudents\n.\nitems\n(),\nkey\n=\nlambda\nitem\n:\nitem\n[\n0\n]))\n{\n'Alice': 89.5,\n'Bob': 76.0,\n'Charlie': 92.3,\n'Diana': 84.7,\n'Ethan': 88.9,\n'Fiona': 95.6,\n'George': 73.4,\n'Hannah': 81.2\n}\nIn this example, you sort the dictionary by keys using a\nlambda\nfunction that returns the first value in the input tuple.\nFinally, you can also use\nsorted()\nto sort the keys and values:\nPython\n>>>\nsorted\n(\nstudents\n)\n['Alice', 'Bob', 'Charlie', 'Diana', 'Ethan', 'Fiona', 'George', 'Hannah']\n>>>\nsorted\n(\nstudents\n.\nvalues\n())\n[73.4, 76.0, 81.2, 84.7, 88.9, 89.5, 92.3, 95.6]\nIn the first call to\nsorted()\n, you use the dictionary as an argument. This results in a list of sorted keys. Next, you use the\n.values()\nmethod to get a list of sorted values.\nSumming Dictionary Values:\nsum()\nYou can also use the built-in\nsum()\nfunction with dictionaries. For example, you can use the function to sum up numeric dictionary values or keys.\nNote:\nTo learn more about about\nsum()\n, check out\nPython’s\nsum()\n: The Pythonic Way to Sum Values\n.\nTo illustrate, say that you have a dictionary containing daily sales data and want to know the average daily sales. In this scenario, you can do something like the following:\nPython\n>>>\ndaily_sales\n=\n{\n...\n\"Monday\"\n:\n1500\n,\n...\n\"Tuesday\"\n:\n1750\n,\n...\n\"Wednesday\"\n:\n1600\n,\n...\n\"Thursday\"\n:\n1800\n,\n...\n\"Friday\"\n:\n2000\n,\n...\n\"Saturday\"\n:\n2200\n,\n...\n\"Sunday\"\n:\n2100\n,\n...\n}\n>>>\nsum\n(\ndaily_sales\n.\nvalues\n())\n/\nlen\n(\ndaily_sales\n)\n1850.0\nIn this example, you use the\nsum()\nfunction to calculate the total sales. To do this, you use the\n.values()\nmethod. Then, you compute the average with the help of\nlen()\n.\nRemove ads\nIterating Over Dictionaries\nIterating over data collections, including dictionaries, is a common task in programming. In this sense, Python dictionaries are pretty versatile, allowing you to iterate over their keys, values, and items.\nNote:\nTo learn more about dictionary iteration, check out the\nHow to Iterate Through a Dictionary in Python\ntutorial.\nIn the following sections, you’ll learn the basics of iterating over Python dictionaries and their components. To kick things off, you’ll start by iterating over dictionary keys.\nTraversing Dictionaries by Keys\nThere are two different ways you can iterate over the keys of a dictionary. You can either use the dictionary directly, or use the\n.keys()\nmethod. The following examples show how to use these two approaches:\nPython\n>>>\nstudents\n=\n{\n...\n\"Alice\"\n:\n89.5\n,\n...\n\"Bob\"\n:\n76.0\n,\n...\n\"Charlie\"\n:\n92.3\n,\n...\n\"Diana\"\n:\n84.7\n,\n...\n\"Ethan\"\n:\n88.9\n,\n...\n\"Fiona\"\n:\n95.6\n,\n...\n\"George\"\n:\n73.4\n,\n...\n\"Hannah\"\n:\n81.2\n,\n...\n}\n>>>\nfor\nstudent\nin\nstudents\n:\n...\nprint\n(\nstudent\n)\n...\nAlice\nBob\nCharlie\nDiana\nEthan\nFiona\nGeorge\nHannah\n>>>\nfor\nstudent\nin\nstudents\n.\nkeys\n():\n...\nprint\n(\nstudent\n)\n...\nAlice\nBob\nCharlie\nDiana\nEthan\nFiona\nGeorge\nHannah\nIn these examples, you first iterate over the keys of a dictionary using the dictionary directly in the loop header. In the second loop, you use the\n.keys()\nmethod to iterate over the keys. Both loops are equivalent. The second loop is more explicit and readable, but it can be less efficient than the first loop because of the additional method call.\nNote that in both loops, you can access the dictionary values as well:\nPython\n>>>\nfor\nstudent\nin\nstudents\n:\n...\nprint\n(\nstudent\n,\n\"->\"\n,\nstudents\n[\nstudent\n])\n...\nAlice -> 89.5\nBob -> 76.0\nCharlie -> 92.3\nDiana -> 84.7\nEthan -> 88.9\nFiona -> 95.6\nGeorge -> 73.4\nHannah -> 81.2\nTo access the values in this type of iteration, you can use the original dictionary and a key lookup operation, as shown in the highlighted line.\nIterating Over Dictionary Values\nWhen it comes to iterating through dictionary values, you can use the\n.values()\nmethod to feed the loop. To illustrate, say that you’re working with the\nMLB_teams\ndictionary and need to iterate over the team names only:\nPython\n>>>\nMLB_teams\n=\n{\n...\n\"Colorado\"\n:\n\"Rockies\"\n,\n...\n\"Chicago\"\n:\n\"White Sox\"\n,\n...\n\"Boston\"\n:\n\"Red Sox\"\n,\n...\n\"Minnesota\"\n:\n\"Twins\"\n,\n...\n\"Milwaukee\"\n:\n\"Brewers\"\n,\n...\n\"Seattle\"\n:\n\"Mariners\"\n,\n...\n}\n>>>\nfor\nteam\nin\nMLB_teams\n.\nvalues\n():\n...\nprint\n(\nteam\n)\n...\nRockies\nWhite Sox\nRed Sox\nTwins\nBrewers\nMariners\nTo iterate over the values of a dictionary, you can use the\n.values()\nmethod. In this example, you iterate over the registered MLB teams one by one. Note that when you use the\n.values()\nmethod, you can’t access the dictionary keys.\nLooping Through Dictionary Items\nFinally, in many cases, you’ll need to iterate over both keys and values in a Python dictionary. In this case, the recommended and most Pythonic approach is to use the\n.items()\nmethod:\nPython\n>>>\nfor\nplace\n,\nteam\nin\nMLB_teams\n.\nitems\n():\n...\nprint\n(\nplace\n,\n\"->\"\n,\nteam\n)\n...\nColorado -> Rockies\nChicago -> White Sox\nBoston -> Red Sox\nMinnesota -> Twins\nMilwaukee -> Brewers\nSeattle -> Mariners\nWhen iterating over keys and values this way, you typically use a tuple of loop variables. The first variable will get the key, while the second will get the associated value. In this example, you have the\nplace\nand\nteam\nvariables, which make the code clear and readable.\nExploring Existing Dictionary-Like Classes\nIn the Python standard library, you’ll find a few dictionary-like classes that have been adapted to perform specific tasks. The most notable examples are the following:\nClass\nDescription\nOrderedDict\nA dictionary subclass specially designed to remember the order of items, which is defined by the insertion order of keys.\nCounter\nA dictionary subclass specially designed to provide efficient counting capabilities out of the box.\ndefaultdict\nA dictionary subclass specially designed to handle missing keys in dictionaries.\nAll these classes and a few others are available in the\ncollections\nmodule found in the Python standard library.\nOrderedDict\nisn’t that useful anymore because since Python 3.6, dictionaries keep their items in the same insertion order. However, you may find some interesting differences between\ndict\nand\nOrderedDict\nthat can help you\ndecide which dictionary\nbest suits your needs.\nThe\nCounter\nclass provides an efficient tool convenient for counting objects:\nPython\n>>>\nfrom\ncollections\nimport\nCounter\n>>>\nCounter\n(\n\"mississippi\"\n)\nCounter({'i': 4, 's': 4, 'p': 2, 'm': 1})\nIn this example, you use\nCounter\nto count the letters in a string. The resulting dictionary’s keys are the letters, while the values are the number of occurrences of each letter. Note that the items in a\nCounter\ninstance are sorted in descending order out of the box, which can be useful for building rankings.\nThe\ndefaultdict\nclass automatically creates a new key and generates a default value for it when you try to access or modify a missing key. To illustrate, say that you have the following data in a list of tuples:\nPython\n>>>\nemployees\n=\n[\n...\n(\n\"Sales\"\n,\n\"John\"\n),\n...\n(\n\"Sales\"\n,\n\"Martin\"\n),\n...\n(\n\"Accounting\"\n,\n\"Kate\"\n),\n...\n(\n\"Marketing\"\n,\n\"Elizabeth\"\n),\n...\n(\n\"Marketing\"\n,\n\"Linda\"\n),\n...\n]\nYou want to create a dictionary that uses the departments as keys. Each key should map a list of people working in the department. Here’s how you can do this quickly with\ndefaultdict\n, which is an invaluable tool when you want to group elements together:\nPython\n>>>\nfrom\ncollections\nimport\ndefaultdict\n>>>\ndepartments\n=\ndefaultdict\n(\nlist\n)\n>>>\nfor\ndepartment\n,\nemployee\nin\nemployees\n:\n...\ndepartments\n[\ndepartment\n]\n.\nappend\n(\nemployee\n)\n...\n>>>\ndepartments\ndefaultdict(<class 'list'>,\n{\n'Sales': ['John', 'Martin'],\n'Accounting': ['Kate'],\n'Marketing': ['Elizabeth', 'Linda']\n}\n)\nIn this example, you create a\ndefaultdict\ncalled\ndepartments\nand use a\nfor\nloop\nto iterate through your\nemployees\nlist. The line\ndepartments[department].append(employee)\ncreates the keys for the departments, initializes them to an empty list if necessary, and then appends the employees to each department.\nRemove ads\nCreating Custom Dictionary-Like Classes\nYou can also create custom dictionary-like classes in Python. To do this, you can inherit from one of the following classes:\nThe built-in\ndict\nclass\nThe\ncollections.UserDict\nclass\nThe first approach may lead to some issues, but it can work in situations where you want to add functionality that doesn’t imply changing the core functionality of\ndict\n. The second approach is more reliable and safe, and you can use it in most cases.\nNote:\nTo dive deeper into how to create custom dictionary-like classes, check out the\nCustom Python Dictionaries: Inheriting From dict vs UserDict\ntutorial.\nTo illustrate, say that you want to create a dictionary-like class that has in-place sorting capabilities. Here’s a class that does that:\nPython\nsorted_dict.py\nclass\nSortableDict\n(\ndict\n):\ndef\nsort_by_keys\n(\nself\n,\nreverse\n=\nFalse\n):\nsorted_items\n=\nsorted\n(\nself\n.\nitems\n(),\nkey\n=\nlambda\nitem\n:\nitem\n[\n0\n],\nreverse\n=\nreverse\n)\nself\n.\nclear\n()\nself\n.\nupdate\n(\nsorted_items\n)\ndef\nsort_by_values\n(\nself\n,\nreverse\n=\nFalse\n):\nsorted_items\n=\nsorted\n(\nself\n.\nitems\n(),\nkey\n=\nlambda\nitem\n:\nitem\n[\n1\n],\nreverse\n=\nreverse\n)\nself\n.\nclear\n()\nself\n.\nupdate\n(\nsorted_items\n)\nIn this example, you inherit from the built-in\ndict\nclass. On top of the class’s default functionality, you add two new methods for sorting the dictionary by keys and values in place, which means that these methods don’t create a new dictionary object but modify the current one.\nHere’s how your class works in practice:\nPython\n>>>\nfrom\nsorted_dict\nimport\nSortableDict\n>>>\nstudents\n=\nSortableDict\n(\n...\n{\n...\n\"Alice\"\n:\n89.5\n,\n...\n\"Bob\"\n:\n76.0\n,\n...\n\"Charlie\"\n:\n92.3\n,\n...\n\"Diana\"\n:\n84.7\n,\n...\n\"Ethan\"\n:\n88.9\n,\n...\n\"Fiona\"\n:\n95.6\n,\n...\n\"George\"\n:\n73.4\n,\n...\n\"Hannah\"\n:\n81.2\n,\n...\n}\n...\n)\n>>>\nid\n(\nstudents\n)\n4350960304\n>>>\nstudents\n.\nsort_by_values\n(\nreverse\n=\nTrue\n)\n>>>\nstudents\n{\n'Fiona': 95.6,\n'Charlie': 92.3,\n'Alice': 89.5,\n'Ethan': 88.9,\n'Diana': 84.7,\n'Hannah': 81.2,\n'Bob': 76.0,\n'George': 73.4\n}\n>>>\nstudents\n.\nsort_by_keys\n()\n>>>\nstudents\n{\n'Alice': 89.5,\n'Bob': 76.0,\n'Charlie': 92.3,\n'Diana': 84.7,\n'Ethan': 88.9,\n'Fiona': 95.6,\n'George': 73.4,\n'Hannah': 81.2\n}\n>>>\nid\n(\nstudents\n)\n4350960304\nIn this example, you create an instance of\nSortableDict\n. Then, you call the\n.sort_by_values()\nmethod to sort the dictionary by grades in reverse order. Next, you call the\n.sort_by_keys()\nmethod to sort the dictionary alphabetically by student names, which are the keys.\nThe highlighted lines show that the instance identity remains unchanged during the sorting process. This confirms that both the\n.sort_by_keys()\nand\n.sort_by_values()\nmethods modify the dictionary in place rather than creating new dictionaries.\nConclusion\nYou’ve delved into Python’s built-in\ndict\ndata type and learned how to create, access, and modify dictionaries. You’ve explored the methods and operations that make dictionaries a powerful data manipulation and storage tool. Additionally, you’ve discovered how to iterate over dictionaries and use built-in functions to perform various operations on dictionary items.\nUnderstanding dictionaries is a crucial skill for any Python developer because they’re useful in data processing, configuration management, and much more.\nIn this tutorial, you’ve learned how to:\nCreate dictionaries using\nliterals\nand the\ndict()\nconstructor\nUse\noperators\nand\nbuilt-in functions\nwith dictionaries\nRetrieve values from a dictionary using\nkey lookup\nPopulate dictionaries with\nkey assignments\n,\nloops\n, and\ncomprehensions\nUse dictionary\nmethods\nWith these skills, you can confidently use dictionaries to solve several programming challenges and optimize your code for better performance and readability.\nGet Your Code:\nClick here to download the free sample code\nthat you’ll use to learn about dictionaries in Python.\nFrequently Asked Questions\nNow that you have some experience with Python dictionaries, you can use the questions and answers below to check your understanding and recap what you’ve learned.\nThese FAQs are related to the most important concepts you’ve covered in this tutorial. Click the\nShow/Hide\ntoggle beside each question to reveal the answer:\nWhat is a dictionary in Python?\nShow/Hide\nA dictionary in Python is a built-in data type that represents a collection of key-value pairs. It allows efficient retrieval, addition, and modification of data based on unique keys. Dictionaries are mutable, dynamic, efficient, and ordered data structures implemented as hash tables.\nHow do you create a dictionary in Python?\nShow/Hide\nYou can create a dictionary in Python using dictionary literals, which are a series of key-value pairs enclosed in curly braces (\n{}\n). Alternatively, you can use the\ndict()\nconstructor, which can take keyword arguments, another mapping, or an iterable of key-value pairs.\nHow can you access and modify values in a dictionary?\nShow/Hide\nYou can access values in a dictionary by using their corresponding keys in square brackets (\n[]\n). To modify a value, assign a new value to an existing key. If the key doesn’t exist, this operation will add a new key-value pair to the dictionary.\nWhat are some common methods for working with dictionaries?\nShow/Hide\nSome common methods for working with Python dictionaries include\n.get()\nfor retrieving values with a default,\n.setdefault()\nfor setting default values,\n.update()\nfor merging dictionaries,\n.pop()\nfor removing keys, and\n.items()\n,\n.keys()\n, and\n.values()\nfor accessing dictionary elements.\nHow do you iterate over a dictionary in Python?\nShow/Hide\nYou can iterate over a dictionary in Python using loops. To iterate over keys, you can loop directly over the dictionary or use the\n.keys()\nmethod. For values, use the\n.values()\nmethod. To iterate over both keys and values, use the\n.items()\nmethod, which yields key-value pairs as tuples.\nTake the Quiz:\nTest your knowledge with our interactive “Dictionaries in Python” quiz. You’ll receive a score upon completion to help you track your learning progress:\nInteractive Quiz\nDictionaries in Python\nIn this quiz, you'll test your understanding of Python's dict data type. By working through this quiz, you'll revisit how to create and manipulate dictionaries, how to use Python's operators and built-in functions with them, and how they're implemented for efficient data retrieval.\nMark as Completed\nShare\nWatch Now\nThis tutorial has a related video course created by the Real Python team. Watch it together with the written tutorial to deepen your understanding:\nUsing Dictionaries in Python"
}